import { Maybe } from "./maybe.ts";
export * from "./maybe.ts";
export * from "./result.ts";
export { default as compose } from "just-compose";
export { default as pipe } from "just-pipe";
export declare function identity<T>(value: T): T;
export declare function constant<T>(value: T): () => T;
export declare function at(idx: number): <T>(data: T[]) => Maybe<T>;
export declare function at<T>(data: T[], idx: number): Maybe<T>;
type Predicate<T> = (value: T, idx: number, arr: T[]) => boolean;
export declare function find<T>(predicate: Predicate<T>): (data: T[]) => Maybe<T>;
export declare function find<T>(data: T[], predicate: Predicate<T>): Maybe<T>;
export declare function findIndex<T>(predicate: Predicate<T>): (data: T[]) => Maybe<number>;
export declare function findIndex<T>(data: T[], predicate: Predicate<T>): Maybe<number>;
export declare function prop<T extends {}, K1 extends keyof T = keyof T>(data: T, key1: K1): Maybe<T[K1]>;
export declare function prop<T extends {}, K1 extends keyof T = keyof T, K2 extends keyof T[K1] = keyof T[K1]>(data: T, key1: K1, key2: K2): Maybe<T[K1][K2]>;
export declare function prop<T extends {}, K1 extends keyof T = keyof T, K2 extends keyof T[K1] = keyof T[K1], K3 extends keyof T[K1][K2] = keyof T[K1][K2]>(data: T, key1: K1, key2: K2, key: K3): Maybe<T[K1][K2][K3]>;
export declare function prop<T extends {}, K1 extends keyof T = keyof T, K2 extends keyof T[K1] = keyof T[K1], K3 extends keyof T[K1][K2] = keyof T[K1][K2], K4 extends keyof T[K1][K2][K3] = keyof T[K1][K2][K3]>(data: T, key1: K1, key2: K2, key: K3, key4: K4): Maybe<T[K1][K2][K3][K4]>;
export declare function prop<T extends {}, K1 extends keyof T = keyof T, K2 extends keyof T[K1] = keyof T[K1], K3 extends keyof T[K1][K2] = keyof T[K1][K2], K4 extends keyof T[K1][K2][K3] = keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4] = keyof T[K1][K2][K3][K4]>(data: T, key1: K1, key2: K2, key: K3, key4: K4, key5: K5): Maybe<T[K1][K2][K3][K4][K5]>;
